#15.10.10
服务器处理连接请求。
处理登陆请求：如果Status为Online，返回错误信息，如果Status为Break，则注册新socket，更新Status为Online。
登陆成功时lobbyPlayerList加入新的playerData并将其status置为Online。
#15.12.12
服务器处理：
大厅：
创建房间时：
	得到一个可用的RoomNum，
	找到LobbyPlayerList中的playerData将其RNum和SNum改为应该的数字，
	创建RoomData，
	将PlayerData加入到RoomData对应位置，
	将dataCenter中加入创建的RoomData，
	发送给用户创建成功，
	发送给用户当前房间具体信息，
	群发粗略大厅信息。
加入房间时：
	得到房间号rNum，
	将LobbyPlayerList中的对应的PlayerData的RNum和SNum改成对应值，
	将PlayerData加入到对应的RoomData，
	发送给用户加入成功，和房间号，座位号，
	发送详细信息给特定的房间号的人。
#15.10.13
客户端处理：
大厅：
控制Canjoin：
	在index的set函数中，
	如果人数当前选中房间人数小于4，
	而且我所在的RoomNum=0（未加入任何Room），
	就将Canjoin设置为true，否则为false。
控制CanCreat：
	在RoomNum的set函数中，
	如果value！=0，
	意味着已经加入了一个Room，
	CanCreat为false，
	否则为true。
服务器：
大厅：
处理加入房间：
	加入发送给创始人游戏可以开始。
#15.10.14
在服务器的RoomData中加入了string Status显示状态。
服务器：
大厅：
处理开始游戏：
	取得开始游戏房间号，
	改变房间信息的Status属性为“已开始”，
	发送粗略信息到大厅，
	将已经开始游戏的玩家从LobbyPlayerList中去除掉，
	给每个玩家初始发牌，发钱。
	发送给要开始的玩家开始成功“2|4|1|”。 
#15.10.23
客户端：
加入了building和hero类，加入了cardRes类生成卡牌资源。
客户端，在LobbyVM中加入了SeatNum属性，在lobbyV关闭时候传递座位号和人数给gameV。
在GameV创建时候，创建GameVM，在gameVM中创建一个各种都为空的玩家list，按照前面给的玩家数量和座位号，以便后面绑定。
#15.10.24
客户端：
加入了CitadelUC，加入了TestUC，修改了部分GameV，并加以测试。
加入了CenterBuildingMultiUC.xaml，显示多选建筑的情况
加入了CenterBuildingPocket.xaml，显示手牌，selectindex绑定为Index，为单向绑定，界面不向后台传递。
加入了CenterBuildingUC.xaml，显示单选建筑的情况，
加入了CenterHeroUC.xaml，显示单选角色的情况，
加入了CenterPlayerUC.xaml，显示单选玩家的情况，
此处加了单选的UC可以用Interaction绑定cmd，关闭显示。
其中的单选绑定到Index，多选绑定button。
需要的时候下面显示确定取消，分别对应着确定，取消。
CenterBuildingMultiUC.xaml
	Visibility="{Binding IsCenterBuildingMultiVisable, Converter={StaticResource visibilityConverter}}"
	确认选择SelectMultiCmd，CommandParameter="{Binding ElementName=list,Path=SelectedItems}"
	取消选择CancelSelectCmd
	绑定之。
	加上<TextBlock Text="{Binding CenterText}"上面的标题
CenterBuildingPocketUC.xaml
	ItemsSource="{Binding PocketBuildings}"
	Visibility="{Binding IsCenterBuildingPocketVisable, Converter={StaticResource visibilityConverter}}"
#15.10.25
	设置bool[] IsStepFinished标志位标志是否完成
	设置SelectText = new string[] 表示中间的区域的提示显示
	设置SelectMultiCmd表示多选，多选之后判断对应的IsStepFinished，如果为true返回，否则打印出来名称。
	设置SelectCmd表示单选，根据Step判断，如果为true返回，否则打印。
	设置CancelSelectCmd，根据Step关闭中间区域的显示，并且将Index置为-1。
	将IsStepFinished加上1位为14位，为魔术师选择自己的建筑换牌堆。
	在控制台加入我要建筑，我要刺杀，我要偷取，我要与玩家换牌，我要与牌堆换牌，我要摧毁，发动铁匠铺，发动实验室。
	并加上了相应的绑定结果。
	在有铁匠铺的时候，按键可用，
	在有实验室的时候，按键可用，这两个特殊按键要实时检测。
#15.10.26
	考虑了chatUC的设计方案，加上初稿，静待改观。
	此处可以同时测试客户端收到不同的字符串时候对应的改变。
服务器：
	收到初始请求信息数据时候，返回给他们各自的手牌，钱，和其他人的昵称
客户端：
	游戏界面收到首先判断是不是开头为3，否则return。
	完成聊天工作。
	在收到初始信息时更新我的牌堆。
#15.10.29
服务器：
	RoomData加入了int FinishCount标志，标志游戏过程中大家的回复的数量。
	每次收到初始更新请求则FinishCount++，当FinishCount为人数数量时，
	FinishCount变为0，开始请第FinishCount位玩家抽牌，判断FinishCount的值，如果是0，则首先自动盖一张，
	然后将BackHerosId发给国王后面的第FinishCount位玩家，
	判断人数选择2人模式还是多人模式。2人模式选人会对应多，多人模式每人只能选一张。
	首先找到对应FinishCount的座号，发送要选的角色ID，然后发战报给房间中的每个人。
客户端：
	收到选英雄时候，将CenterHeros清零后加入收到的ID，然后置Step为1，关闭中间手牌显示，然后显示中央Hero。
	收到盖下英雄时候，将CenterHeros清零后加入收到的ID，然后置Step为2，关闭中间手牌显示，然后显示中央Hero。
服务器：
	当FinishCount为0时，首先去掉一张牌，然后给下家选牌。
	选牌结束后盖牌，如果是第一个就下个人选牌，否则就盖牌。
	最后一个人选完后将FinishCount置零，开始游戏。
#15.11.16
协议：
	改变战报格式，加入字段代表战报类型。
服务器：
	加入FinishCount的另一个功能，控制回合。
	最后一个人选完之后，FinishCount置零，开始回合，FinishCount自加，向某个人发送回合开始信息。
	向房间内部发送某人作为某个角色开始回合。
服务器：
	开始回合之前，先判断是否被偷，
	被偷则通知小偷和被偷者，后台更新钱，前台更新战报
	然后判断是否被刺杀。
	重要变化，在PlayerData中将IsKill和IsStole变化为两个int变量，代表角色号
	如果被偷，后台操作钱之后通知到小偷和被偷者,并更新战报，并将被偷归零
    如果被杀，通知全体，通知个人，然后将被杀归零,叫到下家开始回合
客户端：
	根据上面收到的提示实时显示到界面
客户端：
	将IsStepFinished增至16位，加入了天文台和图书馆同时用的时候的选牌。
	加上CenterRoundStartUC供玩家进行选择拿牌还是拿钱。
	选择拿钱时候，发送拿钱指令到服务器。并关闭当前显示。
	选择拿牌时候，发送拿牌指令到服务器。并关闭当前显示。
服务器：
	当客户端拿钱时候，加入钱，返回到客户端，发送到房间战报
	当客户端拿牌时候，根据拿的张树，从BackB中拿到ID发送给客户端。群发战报正在选牌
客户端：
	当收到更新钱的时候更新钱的数量。
	当收到可选择建筑牌时候，分为单选多选。更新Step并且更新CenterBuildings。
服务器：
	加入选择拿牌的判断，返回可选的数目。
	加入了对客户端发来建设要求的处理。
客户端：
	对返回来的建筑牌进行显示。
	加入了对两种建设模式的支持。
#15.11.17
客户端：
	建设建筑时候等服务器发送消息更新界面，但是选择建筑牌通过自己更新界面。
	加入建设的钱的削减。
	加入对回合结束的支持。
	部分新的功能加入，没有来得及记…………
#15.11.19
服务器：
	在datacenter中加入了CardRes属性方便使用。
	当让某人选择英雄时先判断如果FinishCount为0则初始化当前backH然后打乱顺序取走首张/。
	在选择英雄时判断英雄的id，给当前的玩家打上主教的标签。
	在最后一个回合结束时判断清空当前Hero2PlayerDic并将国王标签移位，
	并重置playerdata的bool和int。
	注释掉之前回合开始时候移除dic中的项。
客户端：
	将某人回合开始时候选的角色牌在界面中显示，并在回合结束后在界面中去掉。
	断点处需要更改，关于建筑多选的情况。
服务器：
	关于返回建筑牌的战报需要修改。
	加入回合开始时候多发的钱和多发的牌（建筑师独有）。
	加入刺客功能。
客户端：
	加入对上方数据的支持。
服务器：
	加入盗贼功能。客户端选择偷人，到服务器。
	服务器返回可偷的列表，客户端将列表加入list并显示。
	客户端发送到服务器后，服务器将标签打上并群发。
服务器：
	完成魔术师角色技能。
#15.11.23
服务器：
	有主教这个角色时候加上标签并发送“3|3|5|座号|”（回合开始中加入）
	如果是商人则加钱并群发。
	加入一轮结束数据“3|4|2|”（回合开始中加入）
客户端：
	收到主教信号加主教标签，收到一轮结束的信息重置玩家主教标签
客户端：
	军阀点击我要摧毁建筑时候显示玩家列表，去掉自己，去掉主教。
	如果没有可摧毁的角色，则弹出警告窗口。
	然后弹出目标玩家的建筑ID。
	军阀选择玩家之后弹出该玩家的所有建筑（去掉要塞并添加城墙标志位）。
	并且将DestroyedSNum改为该玩家的座号。
	军阀选择了牌之后，先判断城墙，然后判断价格，然后发送到服务器。
服务器：
	收到摧毁的信息之后，将对应的牌从数据中心减去，
	减掉对应的钱，然后发送战报到room。
客户端：
	收到摧毁的战报后，将对应的牌移除掉，然后再将对应的钱减掉。
客户端：
	发动铁匠铺之后，先判断有没有钱。
	如果有则发送到服务器，如果没有显示警告窗口。
服务器：
	收到铁匠铺请求后，先减两个钱，
	然后给某人加三张手牌，发到某人，然后发送战报。
客户端：
	收到添加手牌请求后加入手牌，收到战报后减钱，显示。
#15.11.25
客户端：
	点击发动实验室时候，将Step设置为11，
	将CenterBuildings清零，加入手牌，
	选择手牌后将选择的手牌从手牌中丢弃，
	将手牌ID发送给服务器。
服务器：
	收到发动实验室的请求后，
	首先将牌拿回到牌堆，
	然后将对应玩家的手牌拿掉，
	然后加钱，
	然后群发战报
客户端：
	收到发动实验室的战报时候，
	更新某人的钱。
	然后更新战报。
客户端：
	开局选择牌时候的消息协议发生变化，增加选择和未选择的关系。
服务器：
	收到开局选择牌的时候的消息，按照格式将牌加入到手牌中或者牌堆中。
客户端：
	在用户点击回合结束时候判断手牌数量，
	如果大于4，则提示用户丢弃手牌，
	Step=16，将IsStepFinished【16】设置为false，
	并显示多选界面。
	多选处选择后，将IsStepFinished【16】设置为true，关闭显示
	首先判断剩余的牌是否少于4张，
	如果是，则发送丢弃的牌的ID并将手牌中对应的去掉。并调用回合结束。
	如果不是，则将IsStepFinished【16】设置为false，Step为16，显示多选。
客户端：
	军阀摧毁还要优化，有bug
服务器：
	修正部分bug。
客户端：
	修正部分bug。
#15.12.07
	加入墓地功能。
	当有军阀摧毁时候，
	判断别人有没有墓地这张牌并且钱数目大于0的，
	如果有，则群发墓地是否使用的消息，
	并将军阀的结束回合置暗等待玩家决定是否使用墓地。
	当事人如果选择使用，
	则减当事人的钱数量，
	加到当事人的牌堆中，
	并且群发战报，
	当事人更新钱和牌数目。
	如果当事人不使用，
	则将军阀的结束回合弄亮，
	继续游戏
测试：
	加入测试环节，
	客户端发送测试信息到服务器，
	服务器进行相应的处理之后以合理的形式返回给客户端。
#15.12.09
服务器：
	当客户结束当前回合，
	判断有没有八张建筑牌，
	如果有，判断有没有第一个八张，
	如果没有则第一个，
	如果有则判断有没有第二个，
	如果没有则第二个。
	
	在PlayerData的Score属性中加上函数，
	计算Score。
	
	在第一次发送选牌时候判断游戏是否结束。
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	


	